Intention: Make use of existing tools to parse/pretty print, round
   trip haskell code.

Resources
  Tool support for refactoring haskell programs, Chris Brown
  http://www.cs.kent.ac.uk/projects/refactor-fp/publications/ChrisThesis.pdf

  http://www.haskell.org/onlinereport/

Possible tools
  GHC API
  Buildwrapper
  hint
  haskell-src-exts

  template haskell

Probably in combination

Other things to look at
  haskell-mode
  ghc-mod - uses ghc API directly

  zippers, multirec
    - to keep parse tree and token stream in sync when making changes

Buildwrapper is already IDE-aware

Can a lense be used to present the pfe parse tree as if it were the
   GHC one?

From "Technical Report - Porting HaRe to the GHC API":

The porting process was centered on four modules, 
  RefacLocUtils.hs,
  RefacUtils.hs, 
  RefacTypeSyn.hs and 
  RefacUtils.hs

  RefacTypeUtils?

Looks like ifToCase is a really simple start point: but no tests
           refacDataNewType

-------------------

Dependencies
------------

ghc-mod
  ghc api
  
haskell-src-exts
  buildwrapper (also ghc-api)

buildwrapper
  haskell-src-exts (also ghc-api)

hint
  haskell-src (and ghc-api)

haskell-mode
 - elisp only

-----------------------------

Tasks

1. Understand round-tripping of source using GHC


    getRichTokenStream :: GhcMonad m => Module -> m [(Located Token, String)]

      Give even more information on the source than getTokenStream
      This function allows reconstructing the source completely with
      showRichTokenStream.

    showRichTokenStream :: [(Located Token, String)] -> StringSource

      Take a rich token stream such as produced from
      getRichTokenStream and return source code almost identical to the
      original code (except for insignificant whitespace.)

    Seems to work.

2. Get a handle on Data.Generics / SYB / Stafunski

3. Identify how to modify the GHC output, and push it out again

4. First use GHC types, then see about using SYB et al instead of
   Strafunski


-------------------

Template haskell packages to investigate
loch-th
newtype-th
test-framework-th
th-build
th-expand-syns
th-extras
th-fold
th-instances
th-kinds
th-lift
th-orphans
th-sccs
type-sub-th
zeroth

--------------------------------------------

The type for these kind of identifiers is called PNT (Programatica
   Name Type) and is defined as follows:

  data PNT = PNT (PN HsName Orig) (IdTy Pid) OptSrcLoc


GHC equivalent of PNT seems to be
Located RdrName

----------------------------------------------

Seems the holes in the GHC Staged result will require
 a) Update Strafunski to deal with it; OR
 b) Use Data.Generics, from ghc-syb-utils, to avoid the holes

Equivalences

TP = Type Preserving - used for transformations
TU = Type Unifying - used to query

applyTU - applies a type-unifying strategy

full_tdTU - full traversal, top down

adhocTU allows the function worker to be applied to all nodes in a
   layered data type: it updates a strategy to add type-specific
   behavior so that the function on the left can be applied unless the
   function on the right succeeds.

once_tdTU
  Top-down traversal that performs its argument strategy at most once.

SO

full_tdTU (corresponds to)
 everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
               Summarise all nodes in top-down, left-to-right order


From GHC.SYB.Utils (ghc-syb-utils-0.2.1.0)
everythingStaged :: Stage -> (r -> r -> r) -> r -> GenericQ r -> GenericQ rSource
   Like everything, but avoid known potholes, based on the Stage that
   generated the Ast. 


















-------------------------------------

GHC structures

data ParsedModule Source

  The result of successful parsing.

  Constructors
    ParsedModule	 

     pm_mod_summary :: ModSummary
     pm_parsed_source :: ParsedSource
     pm_extra_src_files :: [FilePath]

---
 
type ParsedSource = Located (HsModule RdrName)

The ModSummary holds compiler housekeeping information

We will work with the ParsedSource, so it is always Located.

